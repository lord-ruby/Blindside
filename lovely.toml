[manifest]
version = "1.0.0"
dump_lua = true
priority = 0

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''if self.name == 'The Wheel' and SMODS.pseudorandom_probability(self, pseudoseed('wheel'), 1, 7, 'wheel') then'''
position = 'before'
match_indent = true
payload = '''
if card.config.center.config.extra and card.config.center.config.extra.flipped or (card.ability and card.ability.extra and card.ability.extra.temp_flipped) then
    return true
end

'''

# static draw from play to discard
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = "draw_card(G.play,G.discard, it*100/play_count,'down', false, v)"
position = 'at'
match_indent = true
payload = '''

local cards_to_hand = {}
for _, c in ipairs(G.play.cards) do
    if c.config.center.key == 'm_bld_house' then
        for __, card in ipairs(G.play.cards) do
        if card ~= c then
            table.insert(cards_to_hand, card)
            end
        end
        break
    end
end

if cards_to_hand ~= {} then
    local condition = false
    for _, card_to_hand in ipairs(cards_to_hand) do
        if v == card_to_hand then
            condition = true
        end
    end
    if condition then
        draw_card(G.play,G.hand, it*100/play_count,'up', true, v)
    else
        draw_card(G.play,G.discard, it*100/play_count,'down', false, v)
    end
else
    draw_card(G.play,G.discard, it*100/play_count,'down', false, v)
end

'''
# collection add blind
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = "UIBox_button({button = 'your_collection_blinds', label = {localize('b_blinds')}, count = G.DISCOVER_TALLIES.blinds, minw = 5, minh = 2.0, id = 'your_collection_blinds', focus_args = {snap_to = true}}),UIBox_button({button = 'your_collection_other_gameobjects', label = {localize('k_other')}, minw = 5, id = 'your_collection_other_gameobjects', focus_args = {snap_to = true}}),"
position = 'at'
match_indent = true
payload = '''
      UIBox_button({button = 'your_collection_blinds', label = {localize('b_blinds')}, count = G.DISCOVER_TALLIES.blinds, minw = 5, minh = 2.0, id = 'your_collection_blinds', focus_args = {snap_to = true}}),UIBox_button({button = 'your_collection_other_gameobjects', label = {localize('k_other')}, minw = 5, id = 'your_collection_other_gameobjects', focus_args = {snap_to = true}}),
    }},
    {n=G.UIT.C, config={align = "cm", padding = 0.15}, nodes={
        {n = G.UIT.O, config = {object = G.Blindside_Collection}}
'''

# collection add blind
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = "function create_UIBox_your_collection()"
position = 'after'
match_indent = true
payload = '''
  G.Blindside_Collection = CardArea(
        0, 0,
    1.05*G.CARD_W,
    1.05*G.CARD_H, 
        {card_limit = 1, type = 'title'})
'''


# collection cardarea add blind click
[[patches]]
[patches.pattern]
target = 'cardarea.lua'
pattern = "function CardArea:click() "
position = 'after'
match_indent = true
payload = '''
    if self == G.Blindside_Collection then 
        G.FUNCS.blindside_collection()
    end
    if self == G.Blindside_Collection then
        G.FUNCS.your_collection()
    end
'''

# collection cardarea add blind click
[[patches]]
[patches.pattern]
target = 'cardarea.lua'
pattern = "function CardArea:update(dt)"
position = 'after'
match_indent = true
payload = '''
    if self == G.Blindside_Collection then 
        self.states.collide.can = true
        self.states.click.can = true
    end
    if self == G.Blindside_Collection then
        self.states.collide.can = true
        self.states.click.can = true
    end
'''


# collection card add blind click
[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = "if self.area and self.area == G.deck and self.area.cards[1] == self then "
position = 'before'
match_indent = true
payload = '''
    if self.area and self.area == G.Blindside_Collection and self.area.cards[1] == self then 
        G.FUNCS.blindside_collection()
    end
    if self.area and self.area == G.Blindside_Back and self.area.cards[1] == self then 
        G.FUNCS.your_collection()
    end
'''


# collection card remove tallies
[[patches]]
[patches.pattern]
target = 'functions/misc_functions.lua'
pattern = "if not v.omit and not v.no_collection then "
position = 'at'
match_indent = true
payload = '''
    if not v.omit and not v.no_collection and not BLINDSIDE.is_blindside(v.key) then 
'''

# collection card remove tallies
[[patches]]
[patches.pattern]
target = 'functions/misc_functions.lua'
pattern = "if not v.no_collection then "
position = 'at'
match_indent = true
payload = '''
    if not v.no_collection and not BLINDSIDE.is_blindside(v.key) then 
'''

# remove all non blindside jokers

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''if add and not G.GAME.banned_keys[v.key] then'''
position = 'before'
match_indent = true
payload = '''
    if (not BLINDSIDE.is_blindside(v.key)) and (G.GAME.selected_back.effect.center.config.extra and G.GAME.selected_back.effect.center.config.extra.blindside) then
        add = false
    end 
'''

# remove all non blindside boosters

[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/overrides.lua"]'
match_indent = true
position = 'before'
pattern = '''
if add and not G.GAME.banned_keys[v.key] then cume = cume + (v.current_weight or 1); temp_in_pool[v.key] = true end
'''
payload = '''
if (not BLINDSIDE.is_blindside(v.key)) and (G.GAME.selected_back.effect.center.config.extra and G.GAME.selected_back.effect.center.config.extra.blindside) then
    add = false
end
'''

# debuff tag
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/overrides.lua"]'
pattern = 'if flags.prevent_debuff then return false end'
position = 'before'
match_indent = true
payload = '''
for i = 1, #G.GAME.tags do
    if G.GAME.tags[i].key == "tag_bld_debuff" and G.GAME.tags[i].ability.debuffed_hand == handname and not (next(SMODS.find_card("j_bld_taglock")) and not (G.GAME.blind.boss or G.GAME.last_joker)) then
        flags.debuff = true
        flags.debuff_text = G.GAME.tags[i].ability.debuff_text
    end
end

'''

# update to blindside shop

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''self:update_shop(dt)'''
position = 'at'
match_indent = true
payload = '''
if G.GAME.selected_back.effect.center.config.extra then
    if not G.GAME.selected_back.effect.center.config.extra.blindside then return self:update_shop(dt) end
    self:blindupdate_shop(dt)
else
self:update_shop(dt)
end

'''

# update to blindside blind hud

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''self.HUD_blind = UIBox{'''
position = 'before'
match_indent = true
payload = '''
if G.GAME.selected_back.effect.center.config.extra and G.GAME.selected_back.effect.center.config.extra.blindside then
    self.HUD_blind = UIBox{
        definition = create_UIBox_HUD_jokerblind(),
        config = {major = G.HUD:get_UIE_by_ID('row_blind_bottom'), align = 'bmi', offset = {x=0,y=-10}, bond = 'Weak'}
    }
else

'''

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''self.HUD_tags = {}'''
position = 'before'
match_indent = true
payload = '''
end
'''

# blindside blind chips area

[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''blind_chips = self.HUD_blind:get_UIE_by_ID('HUD_blind_count'),'''
position = 'before'
match_indent = true
payload = '''
blind_mult_text = self.HUD_blind:get_UIE_by_ID('blind_mult'),
blind_chip_text = self.HUD_blind:get_UIE_by_ID('blind_chips'),
'''
# blindside blind chips

[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''self.chips = get_blind_amount(G.GAME.round_resets.ante)*self.mult*G.GAME.starting_params.ante_scaling'''
position = 'before'
match_indent = true
payload = '''
self.original_mult = self.mult
self.active = self.active
self.small = self.small
self.big = self.big
self.extra = self.extra
self.original_chips = get_blind_amount(G.GAME.round_resets.ante)*G.GAME.starting_params.ante_scaling
self.basechips = get_blind_amount(G.GAME.round_resets.ante)*G.GAME.starting_params.ante_scaling
self.basechips_text = number_format(self.basechips)
self.mult_text = number_format(self.mult)
self.blindassist = blind and blind.blindassist or nil

'''

# blindside blind chips saving
[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''chips = self.chips,'''
position = 'before'
match_indent = true
payload = '''
original_mult = self.original_mult,
original_chips = self.original_chips,
active = self.active,
small = self.small,
extra = self.extra,
big = self.big,
basechips = self.basechips,
basechips_text = self.basechips_text,
mult_text = self.mult_text,
blindassist = self.blindassist,
visible = self.visible,

'''

# blindside blind chips loading
[[patches]]
[patches.pattern]
target = 'blind.lua'
pattern = '''self.chips = blindTable.chips'''
position = 'before'
match_indent = true
payload = '''
self.original_mult = blindTable.original_mult
self.original_chips = blindTable.original_chips
self.active = blindTable.active
self.basechips = blindTable.basechips
self.small = blindTable.small
self.extra = blindTable.extra
self.big = blindTable.big
self.basechips_text = blindTable.basechips_text
self.mult_text = blindTable.mult_text
self.blindassist = blindTable.blindassist
self.visible = blindTable.visible

'''

# custom small/big blinds
[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''G.GAME.round_resets.blind_choices.Boss = get_new_boss()'''
position = 'before'
match_indent = true
payload = '''
G.GAME.round_resets.blind_choices.Small = get_new_small()
G.GAME.round_resets.blind_choices.Big = get_new_big()
'''

# Add Custom Small/Big Blinds
[[patches]]
[patches.pattern]
target = 'game.lua'
match_indent = true
position = 'before'
pattern = '''
self.GAME.round_resets.blind_choices.Boss = get_new_boss()
'''
payload = '''
self.GAME.round_resets.blind_choices.Small = get_new_small()
self.GAME.round_resets.blind_choices.Big = get_new_big()
'''

[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''local min_use = 100'''
position = 'before'
match_indent = true
payload = '''
if G.GAME.selected_back.effect.center.config.extra and G.GAME.selected_back.effect.center.config.extra.blindside then
    for k, v in pairs(eligible_bosses) do
        if eligible_bosses[k] and not G.P_BLINDS[k].mod or G.P_BLINDS[k].mod.id ~= 'Blindside' then
            eligible_bosses[k] = nil
        end
    end
end
'''

[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''if v.boss.showdown then '''
position = "at"
payload = '''if v.boss and v.boss.showdown then '''
match_indent = true


[[patches]]
[patches.pattern]
target = 'blind.lua'
match_indent = true
position = 'after'
pattern = '''
self.name = blind and blind.name or ''
'''
payload = '''
self.small = blind and not not blind.small
self.big = blind and not not blind.big
'''

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
match_indent = true
position = 'at'
pattern = '''
if G.GAME.round_resets.blind == G.P_BLINDS.bl_small then
'''
payload = '''
if G.GAME.round_resets.blind_states.Small == 'Current' then
'''

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
match_indent = true
position = 'at'
pattern = '''
elseif G.GAME.round_resets.blind == G.P_BLINDS.bl_big then
'''
payload = '''
elseif G.GAME.round_resets.blind_states.Big == 'Current' then
'''
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = "SMODS.calculate_context({discard = true, other_card =  G.hand.highlighted[i], full_hand = G.hand.highlighted, ignore_other_debuff = true}, effects)"
position = 'at'
match_indent = true
payload = '''
SMODS.calculate_context({discard = true, other_card =  G.hand.highlighted[i], full_hand = G.hand.highlighted, ignore_other_debuff = true, hook = hook}, effects)
'''

# The Wedge
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = "G.FUNCS.discard_cards_from_highlighted = function(e, hook)"
position = 'after'
match_indent = true
payload = '''

G.hand.wedge_highlighted = {}
local wedge_played = false
local highlightcount = 0

for i = 1, #G.hand.cards do
    if G.hand.cards[i] and G.hand.cards[i].highlighted then
    highlightcount = highlightcount + 1
    end
end
if highlightcount == 1 and next(SMODS.find_card("j_bld_miniature")) and not hook then
    wedge_played = true
end

for i = 1, #G.hand.cards do
    if G.hand.cards[i] and G.hand.cards[i].highlighted
    and G.hand.cards[i].config.center == G.P_CENTERS.m_bld_wedge
    and not G.hand.cards[i].debuff and not hook then
        wedge_played = true
        break
    end
end

for i = 1, #G.hand.cards do
    if G.hand.cards[i] and G.hand.cards[i].highlighted
    and wedge_played then
        table.insert(G.hand.wedge_highlighted, G.hand.cards[i])
        G.hand:remove_from_highlighted(G.hand.cards[i], true)
    end
end

'''

# The Wedge
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = 'G.GAME.current_round.discards_used = G.GAME.current_round.discards_used + 1'
position = 'after'
match_indent = true
payload = '''

if G.hand.wedge_highlighted and #G.hand.wedge_highlighted >= 1 then
    for i = 1, #G.hand.wedge_highlighted do
        if not G.hand.wedge_highlighted[i].highlighted then
            G.hand:add_to_highlighted(G.hand.wedge_highlighted[i], true)
        end
    end
    local highlighted_count = math.min(#G.hand.highlighted, G.discard.config.card_limit - #G.play.cards)
    SMODS.calculate_context({pre_discard = true, full_hand = G.hand.highlighted, hook = hook})
    for i=1, highlighted_count do
        G.hand.highlighted[i]:calculate_seal({discard = true})
        local removed = false
        local effects = {}
        SMODS.calculate_context({discard = true, other_card =  G.hand.highlighted[i], full_hand = G.hand.highlighted, ignore_other_debuff = true}, effects)
        SMODS.trigger_effects(effects)
    end
    G.E_MANAGER:add_event(Event({func = function()
        G.GAME.ignore_hand_played = true
        G.FUNCS.play_cards_from_highlighted()
    return true end}))

    return
end

'''

# The Wedge
[[patches]]
[patches.regex]
target = 'functions/state_events.lua'
pattern = 'end\n(.*)\}\)\)\n(.*)end\n(?<indent>[\t ]*)(.*)end'
position = "after"
line_prepend = "$indent"
payload = '''

if G.hand.wedge_highlighted and #G.hand.wedge_highlighted >= 1 then

    ease_discard(-1)

    for i = 1, #G.hand.wedge_highlighted do
        if not G.hand.wedge_highlighted[i].highlighted then
            G.hand:add_to_highlighted(G.hand.wedge_highlighted[i], true)
        end
    end
    
    local highlighted_count = math.min(#G.hand.highlighted, G.discard.config.card_limit - #G.play.cards)
    SMODS.calculate_context({pre_discard = true, full_hand = G.hand.highlighted, hook = hook})
    for i=1, highlighted_count do
        G.hand.highlighted[i]:calculate_seal({discard = true})
        local removed = false
        local effects = {}
        SMODS.calculate_context({discard = true, other_card =  G.hand.highlighted[i], full_hand = G.hand.highlighted, ignore_other_debuff = true}, effects)
        SMODS.trigger_effects(effects)
    end

    if #G.play.cards ~= 0 then
        for i=1, #G.hand.highlighted do
            if G.hand.highlighted[i] and G.hand.highlighted[i].config.center == G.P_CENTERS.m_bld_wedge then
                G.hand.highlighted[i].base.times_played = G.hand.highlighted[i].base.times_played + 1
                G.GAME.round_scores.cards_played.amt = G.GAME.round_scores.cards_played.amt + 1
                draw_card(G.hand, G.play, i*100/#G.hand.highlighted, 'up', nil, G.hand.highlighted[i])
            end
        end
    end

    G.E_MANAGER:add_event(Event({func = function()
        if #G.play.cards == 0 then
            G.GAME.ignore_hand_played = true
            G.FUNCS.play_cards_from_highlighted()
        end
    return true end}))

    return
end

'''

# The Wedge
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = "ease_hands_played(-1)"
position = 'at'
match_indent = true
payload = '''

if not G.GAME.ignore_hand_played then
    ease_hands_played(-1)
else
    G.GAME.ignore_hand_played = nil
end

'''

# blind shrink
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
match_indent = true
position = 'after'
pattern = '''
SMODS.calculate_context({full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, after = true})
'''
payload = '''
G.E_MANAGER:add_event(Event({
        trigger = 'immediate',
        func = (function()     
BLINDSIDE.chipsupdate()
        return true end)
      }))
'''


[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = "local nu_chip, nu_mult = G.GAME.selected_back:trigger_effect{context = 'final_scoring_step'*"
position = 'before'
match_indent = true
payload = '''

for i = 1, #G.GAME.tags do
    G.GAME.tags[i]:apply_to_run({type = 'after_hand'})
    delay(0.5)
end

'''

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = "SMODS.calculate_context({first_hand_drawn = not G.GAME.current_round.any_hand_drawn and G.GAME.facing_blind,"
position = 'before'
match_indent = true
payload = '''
if not G.GAME.current_round.any_hand_drawn and G.GAME.facing_blind then
for i = 1, #G.GAME.tags do
    G.GAME.tags[i]:apply_to_run({type = 'real_round_start'})
end
end

'''

[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = "SMODS.calculate_context({using_consumeable = true, consumeable = card, area = card.from_area})"
position = 'before'
match_indent = true
payload = '''
for i = 1, #G.GAME.tags do
    G.GAME.tags[i]:apply_to_run({type = 'use_consumeable', consumeable = card, area = card.from_area})
end
'''
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = "function add_tag(_tag)"
position = 'after'
match_indent = true
payload = '''
if _tag.key == 'tag_bld_reroll' then
    SMODS.change_free_rerolls(1)
end

'''


# noir channel card
[[patches]]
[patches.pattern]
target = 'game.lua'
match_indent = true
position = 'after'
pattern = '''last_tarot_planet = nil,
'''
payload = '''
        last_channel = nil,
        last_joker = nil,
        chips_buffer = 0,
        blind_rate = 0,
'''

# blind assists
[[patches]]
[patches.pattern]
target = 'game.lua'
match_indent = true
position = 'after'
pattern = '''
    G.GAME.blind = Blind(0,0,2, 1)
'''
payload = '''
    G.GAME.blindassist = Blind(0,0,2,1)
'''


# blind assists
[[patches]]
[patches.pattern]
target = 'game.lua'
match_indent = true
position = 'after'
pattern = '''
        G.GAME.blind:load(saveTable.BLIND)
'''
payload = '''
        G.GAME.blindassist:load(saveTable.BLINDASSIST)
'''

# blind assists
[[patches]]
[patches.pattern]
target = 'game.lua'
match_indent = true
position = 'after'
pattern = '''
        G.GAME.blind:set_blind(nil, nil, true)
'''
payload = '''
        G.GAME.blindassist:set_blind(nil, nil, true)
'''


# blind assists
[[patches]]
[patches.pattern]
target = 'functions/misc_functions.lua'
match_indent = true
position = 'after'
pattern = '''
    BLIND = G.GAME.blind:save(),
'''
payload = '''
    BLINDASSIST = G.GAME.blindassist:save(),
'''

# blind assists
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
match_indent = true
position = 'after'
pattern = '''
    G.GAME.blind:set_blind(G.GAME.round_resets.blind)
'''
payload = '''
if G.GAME.blind.blindassist then
    G.GAME.blindassist:set_blind(G.GAME.blind.blindassist)
end
'''


# blind assists
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
match_indent = true
position = 'after'
pattern = '''
    SMODS.calculate_context({end_of_round = true, game_over = game_over, beat_boss = G.GAME.blind.boss })
'''
payload = '''
G.GAME.last_joker = G.GAME.blind.boss
'''


# blind assists
[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
match_indent = true
position = 'after'
pattern = '''
      G.GAME.blind.states.visible = true
'''
payload = '''
if G.GAME.blind.blindassist then
      G.GAME.blindassist.states.visible = true
end
'''


# blind assists
[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
match_indent = true
position = 'after'
pattern = '''
      G.GAME.blind.states.visible = false
'''
payload = '''
if G.GAME.blind.blindassist then
      G.GAME.blindassist.states.visible = false
end
'''

# blind assists
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
match_indent = true
position = 'after'
pattern = '''
  blind_choice.animation =  SMODS.create_sprite(0,0, 1.4, 1.4, SMODS.get_atlas(blind_choice.config.atlas) or  'blind_chips',   blind_choice.config.pos) 
'''
payload = '''
  local blind_assist = {}
  if blind_choice.config.get_assist then
    blind_assist.config = blind_choice.config.get_assist()
    blind_assist.animation = AnimatedSprite(0,0, 1.4, 1.4, G.ANIMATION_ATLAS[blind_assist.config.atlas] or G.ANIMATION_ATLAS['blind_chips'],  blind_assist.config.pos)
  	blind_assist.animation:define_draw_steps({
  		{shader = 'dissolve', shadow_height = 0.05},
  		{shader = 'dissolve'}
  	})
  end
'''

# blind assists
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
match_indent = true
position = 'after'
pattern = '''
                {n=G.UIT.O, config={object = blind_choice.animation}},
'''
payload = '''
                blind_assist.config and {n=G.UIT.O, config={object = blind_assist.animation}} or nil,
'''

# blind assists
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
match_indent = true
position = 'before'
pattern = '''-- TARGET: add your own individual scoring targets
'''
payload = '''
        if G.GAME.blindassist and G.GAME.blindassist.children and G.GAME.blindassist.children.animatedSprite and G.GAME.blindassist.config.blind then 
            t[#t + 1] = { object = G.GAME.blindassist, scored_card = G.GAME.blindassist.children.animatedSprite } 
        end
'''

# blind assists
[[patches]]
[patches.pattern]
target = 'blind.lua'
match_indent = true
position = 'after'
pattern = '''
                self:change_colour()
'''
payload = '''
local obj = self.config.blind
if obj.load and type(obj.load) == 'function' then
    obj:load()
end
'''

# wave tag
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
match_indent = true
position = 'before'
pattern = '''
local splashed = SMODS.always_scores(G.play.cards[i]) or next(find_joker('Splash'))
'''
payload = '''
local waved = false
for i = 1, #G.GAME.tags do
    if G.GAME.tags[i].key == "tag_bld_wave" and not (next(SMODS.find_card("j_bld_taglock")) and not (G.GAME.blind.boss or G.GAME.last_joker)) then
        waved = true
    end
end
'''
# wave tag
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
match_indent = true
position = 'after'
pattern = '''
local splashed = SMODS.always_scores(G.play.cards[i]) or next(find_joker('Splash'))
'''
payload = '''
or waved
'''

# wave tag
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/overrides.lua"]'
match_indent = true
position = 'before'
pattern = '''
local splashed = SMODS.always_scores(cards[i]) or next(find_joker('Splash'))
'''
payload = '''
local waved = false
for i = 1, #G.GAME.tags do
    if G.GAME.tags[i].key == "tag_bld_wave"  then
        waved = true
    end
end
'''

# wave tag
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/overrides.lua"]'
match_indent = true
position = 'after'
pattern = '''
local splashed = SMODS.always_scores(cards[i]) or next(find_joker('Splash'))
'''
payload = '''
or waved
'''


# symmetry tag
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
match_indent = true
position = 'after'
pattern = '''
SMODS.score_card(card, context)
'''
payload = '''
for i = 1, #G.GAME.tags do
    G.GAME.tags[i]:apply_to_run({type = 'scoring_card', card = card, context = context})
end
'''


# before tag context
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
match_indent = true
position = 'after'
pattern = '''
SMODS.calculate_context({full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, before = true})
'''
payload = '''
for i = 1, #G.GAME.tags do
    G.GAME.tags[i]:apply_to_run({full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, type = 'before'})
end
'''


# collector tag
[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = "SMODS.calculate_context({open_booster = true, card = self})"
position = 'after'
match_indent = true
payload = '''

for i = 1, #G.GAME.tags do
    if self.config.center.kind == 'symbol' then
        if G.GAME.tags[i]:apply_to_run({type = 'symbol_pack_opened'}) then break end
    end
end 

'''

# reload
[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = 'self:set_sprites(self.config.center, self.config.card)'
match_indent = true
position = 'after'
payload = '''
local obj = self.config.center
if obj.reload and type(obj.reload) == 'function' then
	obj:reload(self, cardTable, other_card)
end
'''

# reshuffle
[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''
if G.FUNCS.draw_from_deck_to_hand(nil) then 
'''
match_indent = true
position = 'before'
payload = '''
if G.GAME.selected_back.effect.center.config.extra and G.GAME.selected_back.effect.center.config.extra.blindside then
if G.FUNCS.blind_draw_from_deck_to_hand(nil) then
    return true
end
else
'''

# reshuffle
[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''
-- removed first hand drawn context
'''
match_indent = true
position = 'before'
payload = '''
end
'''

# [[patches]]
# [patches.pattern]
# target = '=[SMODS _ "src/utils.lua"]'
# pattern = '''
# G.FUNCS.draw_from_deck_to_hand(self.config.card_limits.total_slots - self.config.card_count - (SMODS.cards_to_draw or 0))
# '''
# match_indent = true
# position = 'before'
# payload = '''
# if not BLINDSIDE.draw_queued then
# '''
# 
# [[patches]]
# [patches.pattern]
# target = '=[SMODS _ "src/utils.lua"]'
# pattern = '''
# G.FUNCS.draw_from_deck_to_hand(self.config.card_limits.total_slots - self.config.card_count - (SMODS.cards_to_draw or 0))
# '''
# match_indent = true
# position = 'after'
# payload = '''
# end
# '''
# 
# [[patches]]
# [patches.pattern]
# target = '=[SMODS _ "src/utils.lua"]'
# pattern = '''
# G.FUNCS.draw_from_deck_to_hand((self.config.card_limits.total_slots - self.config.card_limits.old_slots))
# '''
# match_indent = true
# position = 'before'
# payload = '''
# if not BLINDSIDE.draw_queued then
# '''
# 
# [[patches]]
# [patches.pattern]
# target = '=[SMODS _ "src/utils.lua"]'
# pattern = '''
# G.FUNCS.draw_from_deck_to_hand((self.config.card_limits.total_slots - self.config.card_limits.old_slots))
# '''
# match_indent = true
# position = 'after'
# payload = '''
# end
# '''

# exhaust pile
[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''
self.discard = CardArea(
'''
match_indent = true
position = 'before'
payload = '''
self.exhaust = CardArea(
    0, 0,
    CAI.discard_W,CAI.discard_H,
    {card_limit = 500, type = 'discard'})
'''

# exhaust pile
[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''
G.discard.T.x = G.jokers.T.x + G.jokers.T.w/2 + 0.3 + 15
'''
match_indent = true
position = 'before'
payload = '''
G.exhaust.T.x = G.jokers.T.x + G.jokers.T.w/2 + 0.3 + 15
'''

# exhaust pile
[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''
G.discard:hard_set_VT()
'''
match_indent = true
position = 'before'
payload = '''
G.exhaust:hard_set_VT()
'''

# exhaust pile
[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''
elseif card.jimbo  then
'''
match_indent = true
position = 'before'
payload = '''
    elseif card.area == G.exhaust or card.area == G.vouchers then
    y_off = card.area == G.exhaust and -0.35*G.CARD_H or -0.65*G.CARD_H
    card = G.deck.cards[1] or G.deck
    card_aligned = 'tm'
'''

# exhaust pile
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''
G.FUNCS.draw_from_discard_to_deck = function(e)
'''
match_indent = true
position = 'after'
payload = '''
    G.E_MANAGER:add_event(Event({
        trigger = 'immediate',
        func = function()
            local discard_count = #G.exhaust.cards
            for i=1, discard_count do --draw cards from deck
                draw_card(G.exhaust, G.deck, i*100/discard_count,'up', nil ,nil, 0.005, i%2==0, nil, math.max((21-i)/20,0.7))
            end
            return true
        end
      }))
'''

# burn context
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''
-- context.remove_playing_cards calculations
'''
match_indent = true
position = 'before'
payload = '''
local cards_burned = {}

    for _,v in ipairs(SMODS.get_card_areas('playing_cards', 'destroying_cards')) do
        BLINDSIDE.calculate_burning_cards({ full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, cardarea = v }, cards_burned, v == G.play and scoring_hand or nil)
    end

    SMODS.calculate_context({scoring_hand = scoring_hand, remove_playing_cards = true, cards_burned = cards_burned})

    for i=1, #cards_burned do
        G.E_MANAGER:add_event(Event({
            func = function()
                cards_burned[i]:start_burn(cards_burned[i].area)
                return true
            end
            }))
    end
'''

# exhaust pile
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''
if (not v.shattered) and (not v.destroyed) then 
'''
match_indent = true
position = 'at'
payload = '''
        if (not v.shattered) and (not v.destroyed) and (not v.burned) then 
'''

# exhaust pile
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
pattern = '''
        -- TARGET: add your own CardAreas for playing card evaluation
'''
match_indent = true
position = 'before'
payload = '''
t[#t+1] = G.exhaust
'''

# held in hand repetitions
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
pattern = '''
        -- TARGET: add your own CardAreas for joker evaluation
'''
match_indent = true
position = 'before'
payload = '''
t[#t+1] = G.hand
'''

# current round trinkets
[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''
G.GAME.current_round.hands_left = G.GAME.round_resets.hands
'''
match_indent = true
position = 'after'
payload = '''
if G.GAME.selected_back.effect.center.config.extra and G.GAME.selected_back.effect.center.config.extra.blindside then
self.GAME.current_round.trinket = BLINDSIDE.get_next_trinket()
G.GAME.round_resets.tags_bought = 0 
end
'''

# current round trinkets
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''
G.GAME.current_round.voucher = SMODS.get_next_vouchers()
'''
match_indent = true
position = 'after'
payload = '''
if G.GAME.selected_back.effect.center.config.extra and G.GAME.selected_back.effect.center.config.extra.blindside then
for i = 1, G.GAME.shop.joker_max do
    G.GAME.current_round.trinket = BLINDSIDE.get_next_trinket()
end
-- G.GAME.round_resets.tags_bought = 0
if not G.GAME.round_resets.hands_removed then
    G.GAME.round_resets.hands_removed = 0
end
G.GAME.round_resets.hands = G.GAME.round_resets.hands + G.GAME.round_resets.hands_removed
G.GAME.round_resets.hands_removed = 0
end
'''

# current round trinkets
[[patches]]
[patches.pattern]
target = 'functions/button_callbacks.lua'
pattern = '''
G.jokers:emplace(c1)
'''
match_indent = true
position = 'after'
payload = '''
if c1.shop_voucher then G.GAME.current_round.trinket.spawn[c1.config.center_key] = false end
'''

# voucher refresh
[[patches]]
[patches.pattern]
target = 'card.lua'
pattern = '''
if self.shop_voucher then G.GAME.current_round.voucher.spawn[self.config.center_key] = false end
'''
match_indent = true
position = 'after'
payload = '''
if self.shop_voucher and G.GAME.selected_back.effect.center.config.extra and G.GAME.selected_back.effect.center.config.extra.blindside then 
G.GAME.current_round.voucher = SMODS.get_next_vouchers()
G.GAME.round_resets.tags_bought = G.GAME.round_resets.tags_bought + 1
for _, key in ipairs(G.GAME.current_round.voucher or {}) do
    if G.P_CENTERS[key] and G.GAME.current_round.voucher.spawn[key] then
        SMODS.add_voucher_to_shop(key)
        G.shop_vouchers.cards[1].cost = math.max(G.shop_vouchers.cards[1].cost + 5*G.GAME.round_resets.tags_bought - (G.GAME.used_vouchers['v_bld_treasurechest'] and 20 or 0), 0)
    end
end
end
'''


# reshufles this round
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''
G.GAME.current_round.discards_used = 0
'''
match_indent = true
position = 'after'
payload = '''
G.GAME.current_round.reshuffles_round = 0
'''

# reshufles this round
[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''
        hands_played = 0,
'''
match_indent = true
position = 'after'
payload = '''
reshuffles_round = 0,
'''

# burn when discarded
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''
G.hand.highlighted[i].ability.discarded = true
'''
match_indent = true
position = 'before'
payload = '''
if burned then
    burned_cards[#burned_cards + 1] = G.hand.highlighted[i]
    G.hand.highlighted[i]:start_burn(G.hand)
    else
'''


# burn when discarded
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''
draw_card(G.hand, G.discard, i*100/highlighted_count, 'down', false, G.hand.highlighted[i])
'''
match_indent = true
position = 'after'
payload = '''
end
'''


# burn when discarded
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''
if key == 'remove' or (type(eval2) == 'table' and eval2.remove) then removed = true end
'''
match_indent = true
position = 'after'
payload = '''
if key == 'burn' or (type(eval2) == 'table' and eval2.burn) then burned = true end
'''

# burn when discarded
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''
local removed = false
'''
match_indent = true
position = 'after'
payload = '''
local burned = false
'''

# burn when discarded
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''
        local destroyed_cards = {}
'''
match_indent = true
position = 'after'
payload = '''
        local burned_cards = {}
'''

# burn when discarded
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''
-- context.remove_playing_cards from discard
'''
match_indent = true
position = 'after'
payload = '''
if burned_cards[1] then
            SMODS.calculate_context({remove_playing_cards = true, cards_burned = burned_cards})
        end
'''

# the spear money for mult
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
pattern = '''
ease_dollars(amount)
'''
match_indent = true
position = 'after'
payload = '''
for i = 1, #G.GAME.tags do
    G.GAME.tags[i]:apply_to_run({type = 'after_money'})
end
'''

# experimental change, replace some of this code later
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
match_indent = true
position = 'after'
pattern = '''
SMODS.calculate_context({full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, after = true})
'''
payload = '''
if G.GAME.selected_back.effect.center.config.extra and G.GAME.selected_back.effect.center.config.extra.blindside then
    local any_selected = nil
    local _cards = {}
    local magnet = false
    for i = 1, #G.GAME.tags do
        if G.GAME.tags[i].key == "tag_bld_magnet_relic" then
            magnet = true
        end
    end
    for k, v in ipairs(G.hand.cards) do
        if not ((magnet and v.ability.extra and v.ability.extra.upgraded) or (v.config.center.config.extra and v.config.center.config.extra.retain) or v.seal == 'bld_sticky' or v.retain or (v.ability.extra and v.ability.extra.retain)) or v.burned then
        _cards[#_cards+1] = v
        end
        v.retain = false
    end
        local cards = {}
        local burned_cards = {}
        local destroyed_cards = {}
    G.E_MANAGER:add_event(Event({
            trigger = 'immediate',
            func = function()
    for i = 1, #_cards do
    local removed = false
            local burned = false
            local effects = {}
            SMODS.calculate_context({hand_discard = true, other_card =  _cards[i], full_hand = _cards, ignore_other_debuff = true}, effects)
            SMODS.trigger_effects(effects)
            for _, eval in pairs(effects) do
                if type(eval) == 'table' then
                    for key, eval2 in pairs(eval) do
                        if key == 'remove' or (type(eval2) == 'table' and eval2.remove) then removed = true end
                        if key == 'burn' or (type(eval2) == 'table' and eval2.burn) then burned = true end
                    end
                end
            end
            table.insert(cards, _cards[i])
            if removed then
                destroyed_cards[#destroyed_cards + 1] = cards[i]
                if SMODS.shatters(cards[i]) then
                    cards[i]:shatter()
                else
                    cards[i]:start_dissolve()
                end
            else 
                if burned then
                    burned_cards[#burned_cards + 1] = cards[i]
                    cards[i]:start_burn(G.hand)
                else
                    cards[i].ability.discarded = true
                    draw_card(G.hand, G.discard, i*100/#cards, 'down', false, cards[i])
                end
            end
    end
    return true end }))
    if burned_cards[1] then
        SMODS.calculate_context({remove_playing_cards = true, cards_burned = burned_cards})
    end
    if destroyed_cards[1] then
        SMODS.calculate_context({remove_playing_cards = true, removed = destroyed_cards})
    end
end
'''

# the spear money for mult
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
pattern = '''
-- TARGET: effects after end of round evaluation
'''
match_indent = true
position = 'after'
payload = '''
for i = 1, #G.playing_cards do
    if card.ability and card.ability.extra and card.ability.extra.temp_flipped then
        card.ability.extra.temp_flipped = false
    end
end
'''

# cardarea sorting
[[patches]]
[patches.pattern]
target = 'cardarea.lua'
pattern = '''
self.config.sort = config.sort or 'desc'
'''
match_indent = true
position = 'after'
payload = '''
if G.GAME.selected_back.effect.center.config.extra and G.GAME.selected_back.effect.center.config.extra.blindside then
self.config.sort = config.sort or 'color desc'
end
'''

# skipping costs $2 per ante
# thank you to CCC (celeste card collection) for this code and the following 3 patches
[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "G.FUNCS.skip_blind = function(e)"
position = "after"
payload = '''
if G.GAME and G.GAME.modifiers and G.GAME.modifiers.enable_bld_skip_costs_money then
	local skipcost = 2*(G.GAME.round_resets.ante)
	if -skipcost < 0 then
		if to_big( (G.GAME.dollars-G.GAME.bankrupt_at) - skipcost ) < to_big(0) then
			e.disable_button = false
			return
		end
	end
	if -skipcost ~= 0 then
		ease_dollars(-skipcost)
	end
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = "{n=G.UIT.T, config={text = localize('b_skip_blind'), scale = 0.4, colour = G.C.UI.TEXT_INACTIVE}}"
position = "at"
payload = '''
{n=G.UIT.T, config={text = localize('b_skip_blind')..(
	G.GAME and G.GAME.modifiers and G.GAME.modifiers.enable_bld_skip_costs_money and 
		((-2*(G.GAME.round_resets.ante))<0 and ' (-' or ' (')..localize('$')..math.abs(-2*(G.GAME.round_resets.ante))..')' 
	or ''
), scale = 0.4, colour = G.C.UI.TEXT_INACTIVE}}
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''_blind_choice.alignment.offset.y = -0.9
if _tag and _tag_container then'''
position = "after"
payload = '''
if not ( G.GAME.modifiers.enable_bld_skip_costs_money and to_big( (G.GAME.dollars-G.GAME.bankrupt_at) - (2*(G.GAME.round_resets.ante)) ) < to_big(0) ) then
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "_sprite.config.force_focus = nil"
position = "after"
payload = '''
else
	_tag.children[2].config.button = 'skip_blind'	-- should be nil but tag colour isn't updating
	_tag.config.outline_colour = G.C.UI.BACKGROUND_INACTIVE
	_tag.children[2].config.hover = false
	_tag.children[2].config.colour = G.C.UI.BACKGROUND_INACTIVE
	_tag.children[2].children[1].config.colour = G.C.UI.TEXT_INACTIVE
	local _sprite = _tag.config.ref_table
	_sprite.config.force_focus = true
end
'''
match_indent = true

#playing with fire
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''if G.GAME.current_round.hands_left > 0 and not G.GAME.modifiers.no_extra_hand_money then'''
position = "before"
payload = '''
if (G.GAME.playing_with_fire or 0) > 0 then
    if G.GAME.playing_with_fire >= 8 then
        unlock_card(G.P_CENTERS.b_bld_yellowdispenser)
    end
    add_round_eval_row({dollars = G.GAME.playing_with_fire, number = G.GAME.playing_with_fire_num, bonus='true', name='custom', text = localize('bld_playing_with_fire') .. ' (' .. localize(G.GAME.playing_with_fire_each) .. ')', pitch = pitch})
    dollars = dollars + G.GAME.playing_with_fire
    G.GAME.playing_with_fire_num = 0
    G.GAME.playing_with_fire = 0
end
'''
match_indent = true


[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''if G.GAME.current_round.hands_left > 0 and not G.GAME.modifiers.no_extra_hand_money then'''
position = "before"
payload = '''
for k, tag in pairs(G.GAME.tags) do
    if tag.key == 'tag_bld_neon' and not tag.triggered then
        if G.GAME.current_round.hands_left > 0 then
            add_round_eval_row({dollars = G.GAME.current_round.hands_left * 3, bonus='true', number = G.GAME.current_round.hands_left, name='bld_neon_hands', text = localize('bld_neon_hands'), pitch = pitch})
            dollars = dollars + G.GAME.current_round.hands_left * 3
        end
        if G.GAME.current_round.discards_left > 0 then
            add_round_eval_row({dollars = G.GAME.current_round.discards_left * 5, bonus='true', number = G.GAME.current_round.discards_left, name='bld_neon_discards', text = localize('bld_neon_discards'), pitch = pitch})
            dollars = dollars + G.GAME.current_round.discards_left * 5
        end
    end
end
'''
match_indent = true


# allow for multiple custom eval rows
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''elseif config.name == 'custom' then'''
position = "before"
payload = '''
elseif config.name == 'bld_neon_hands' then
    table.insert(left_text, {n=G.UIT.T, config={text = config.number, scale = 0.8*scale, colour = G.C.BLUE, shadow = true, juice = true}})
    table.insert(left_text, {n=G.UIT.O, config={object = DynaText({string = {" "..config.text}, colours = {G.C.UI.TEXT_LIGHT}, shadow = true, pop_in = 0, scale = 0.4*scale, silent = true})}})
elseif config.name == 'bld_neon_discards' then
    table.insert(left_text, {n=G.UIT.T, config={text = config.number, scale = 0.8*scale, colour = G.C.RED, shadow = true, juice = true}})
    table.insert(left_text, {n=G.UIT.O, config={object = DynaText({string = {" "..config.text}, colours = {G.C.UI.TEXT_LIGHT}, shadow = true, pop_in = 0, scale = 0.4*scale, silent = true})}})
'''
match_indent = true


[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/utils.lua"]'
pattern = '''if (area.config.type == 'joker' or area.config.type == 'hand') and not area.config.fixed_limit then'''
position = "at"
payload = '''
if (area.config.type == 'joker' or area.config.type == 'hand' and not (G.GAME.selected_back.effect.center.config.extra and G.GAME.selected_back.effect.center.config.extra.blindside) ) and not area.config.fixed_limit then
'''
match_indent = true


# joker text
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = "{n=G.UIT.T, config={text = localize('ph_defeat_this_blind_1'), scale = 0.4, colour = G.C.UI.TEXT_DARK}},"
position = 'at'
match_indent = true
payload = '''
BLINDSIDE.is_blindside(blind.key) and{n=G.UIT.T, config={text = localize('ph_defeat_this_joker_1'), scale = 0.4, colour = G.C.UI.TEXT_DARK}} or {n=G.UIT.T, config={text = localize('ph_defeat_this_blind_1'), scale = 0.4, colour = G.C.UI.TEXT_DARK}},
'''

# microscope
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.set == 'Booster' then"
position = "after"
payload = '''
    if G.GAME.used_vouchers.v_bld_satellite and self.config.center.kind == 'channel' then
        self.ability.choose = (self.ability.choose or 1) + 1
    end
'''
match_indent = true

# clapper
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''UIBox_button({label = {localize('b_reroll_boss'), localize('$')..'10'}, button = "reroll_boss", func = 'reroll_boss_button'}) or nil'''
position = "at"
payload = '''
UIBox_button({label = {localize('b_reroll_boss'), localize('$')..'10'}, button = "reroll_boss", func = 'reroll_boss_button'}) or nil,
(G.GAME.used_vouchers["v_bld_clapper"] or G.GAME.used_vouchers["v_bld_film_reel"]) and
UIBox_button({label = {localize('b_reroll_boss'), '1 Hand'}, button = "blind_reroll_boss", func = 'blind_reroll_boss_button'}) or nil,
'''
match_indent = true

# blindsoul
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''for _, v in ipairs(SMODS.Consumable.legendaries) do'''
position = "before"
payload = '''
for _, v in ipairs(SMODS.Consumable.legendaries) do
    for _, soul_set in ipairs(v.soul_sets) do
        if (_type == soul_set) and not (G.GAME.used_jokers[v.key] and not SMODS.showman(v.key) and not v.can_repeat_soul) and SMODS.add_to_pool(v) then
            soul_total_rate = soul_total_rate + v.soul_rate
            non_soul_rate = non_soul_rate * (1 - v.soul_rate)
            non_soul_rate = math.max(non_soul_rate, 0)
            table.insert(modded_souls, v)
        end
    end
end
'''
match_indent = true

# logo
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''G.SPLASH_LOGO.dissolve = 1   '''
position = "after"
payload = '''
G.BLINDSIDE_LOGO = Sprite(0, 0, 
        13*SC_scale, 
        13*SC_scale*(G.ASSET_ATLAS["bld_logo"].py/G.ASSET_ATLAS["bld_logo"].px),
        G.ASSET_ATLAS["bld_logo"], {x=0,y=0})

    G.BLINDSIDE_LOGO:set_alignment({
        major = G.title_top,
        type = 'cm',
        bond = 'Strong',
        offset = {x=0,y=0.4}
    })
    G.BLINDSIDE_LOGO:define_draw_steps({{
            shader = 'dissolve',
        }})

    G.BLINDSIDE_LOGO.dissolve_colours = {G.C.WHITE, G.C.WHITE}
    G.BLINDSIDE_LOGO.dissolve = 1   
'''
match_indent = true

# logo
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''if G.debug_splash_size_toggle then '''
position = "before"
payload = '''
    if G.BLINDSIDE_LOGO then
        love.graphics.push()
        G.BLINDSIDE_LOGO:translate_container()
        G.BLINDSIDE_LOGO:draw()
        love.graphics.pop()
    end 
'''
match_indent = true

# logo
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''ease_value(G.SPLASH_LOGO, 'dissolve', -1, nil, nil, nil, change_context == 'splash' and 2.3 or 0.9)'''
position = "before"
payload = '''
ease_value(G.BLINDSIDE_LOGO, 'dissolve', -1, nil, nil, nil, change_context == 'splash' and 2.3 or 0.9)
'''
match_indent = true

# logo
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''self.title_top = CardArea('''
position = "before"
payload = '''
    self.blindside_title_top = CardArea(
        0, 0,
        CAI.TITLE_TOP_W,CAI.TITLE_TOP_H,
        {card_limit = 1, type = 'title'})
'''
match_indent = true

# logo
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''replace_card.ambient_tilt = 0.0'''
position = "before"
payload = '''
local blind_card = Card(self.blindside_title_top.T.x, self.blindside_title_top.T.y, 1.2*G.CARD_W*SC_scale, 1.2*G.CARD_H*SC_scale, G.P_CARDS.S_A, G.P_CENTERS.m_bld_flip)
    self.blindside_title_top:emplace(blind_card)

    blind_card.states.visible = false
    blind_card.no_ui = true
    blind_card.ambient_tilt = 0.2
'''
match_indent = true

# logo
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''if change_context == 'splash' then '''
position = "before"
payload = '''
            if change_context == 'splash' then 
                blind_card.states.visible = true
                blind_card:start_materialize({G.C.WHITE,G.C.WHITE}, true, 2.5)
                play_sound('whoosh1', math.random()*0.1 + 0.3,0.3)
                play_sound('crumple'..math.random(1,5), math.random()*0.2 + 0.6,0.65)
            else
                blind_card.states.visible = true
                blind_card:start_materialize({G.C.WHITE,G.C.WHITE}, nil, 1.2)
            end
'''
match_indent = true

# logo
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''self.title_top:hard_set_cards()'''
position = "after"
payload = '''
    self.blindside_title_top:sort('order')
    self.blindside_title_top:set_ranks()
    self.blindside_title_top:align_cards()
    self.blindside_title_top:hard_set_cards()
'''
match_indent = true

# logo
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''G.title_top.T.y = G.TILE_H/2 - G.title_top.T.h/2 -(G.debug_splash_size_toggle and 2 or 1.2)--|||||||||||||||||'''
position = "after"
payload = '''
G.blindside_title_top.T.x = G.TILE_W/2 - G.blindside_title_top.T.w/2
G.blindside_title_top.T.y = G.TILE_H/2 - G.blindside_title_top.T.h/2 -(G.debug_splash_size_toggle and 2 or 1.2) + 3.4
'''
match_indent = true

# logo
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''G.title_top:hard_set_VT()'''
position = "after"
payload = '''
G.blindside_title_top:hard_set_VT()
'''
match_indent = true

# logo
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''if self.SPLASH_LOGO then self.SPLASH_LOGO:remove(); self.SPLASH_LOGO = nil end'''
position = "after"
payload = '''
        if self.BLINDSIDE_LOGO then self.BLINDSIDE_LOGO:remove(); self.BLINDSIDE_LOGO = nil end
'''
match_indent = true

# credits
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''      local cols'''
position = "before"
payload = '''
if AUT.credits then
    local name_nodes = {{n=G.UIT.T, config={text = "Artist", scale = 0.32, colour = G.C.UI.TEXT_LIGHT}}}
    local t = {
	{n=G.UIT.R, config={align = "cm"}, nodes={
		{n=G.UIT.T, config={text = "Art by ", colour = G.C.UI.TEXT_DARK, scale = 0.33}},
		{n=G.UIT.T, config={text = AUT.credits.art, colour = G.C.ORANGE, scale = 0.33}},
        }}
    }
    local artistdisplay = {n=G.UIT.R, config={align = "cm", colour = lighten(G.C.GREY, 0.15), r = 0.1}, nodes={
      {n=G.UIT.R, config={align = "tm", minh = 0.36, padding = 0.03}, nodes=name_nodes},
      {n=G.UIT.R, config={align = "cm", minw = 1.5, minh = 0.4, r = 0.1, padding = 0.05, colour = G.C.WHITE}, nodes={{n=G.UIT.R, config={align = "cm", padding = 0.03}, nodes=t}}}
    }}
info_boxes[#info_boxes+1] =
    {n=G.UIT.R, config={align = "cm"}, nodes={
        {n=G.UIT.R, config={align = "cm", colour = lighten(G.C.JOKER_GREY, 0.5), r = 0.1, padding = 0.05, emboss = 0.05}, nodes={
        artistdisplay
        }}
    }}
end
'''
match_indent = true

